#!/usr/bin/env node

/**
 * Korsakov Base Adapter
 * Abstract base class for vendor-specific adapters
 */

const fs = require('fs');
const path = require('path');
const { getMarkdownFiles, readMarkdownFile, extractFirstHeading } = require('../core/utils');

/**
 * Base adapter class - all vendor adapters extend this
 */
class BaseAdapter {
  constructor(templatesDir) {
    this.templatesDir = templatesDir;
  }

  // Abstract properties - must override
  get vendorName() {
    throw new Error('vendorName must be implemented');
  }

  get vendorId() {
    throw new Error('vendorId must be implemented');
  }

  get vendorDescription() {
    throw new Error('vendorDescription must be implemented');
  }

  // Abstract methods - must implement
  getOutputPath(projectRoot) {
    throw new Error('getOutputPath must be implemented');
  }

  async generate(config, projectRoot) {
    throw new Error('generate must be implemented');
  }

  cleanup(projectRoot) {
    throw new Error('cleanup must be implemented');
  }

  // Capability queries - can override
  canUseSymlinks() {
    return false;
  }

  supportsSlashCommands() {
    return false;
  }

  supportsSkillTool() {
    return false;
  }

  usesSingleFile() {
    return false;
  }

  usesDirectoryStructure() {
    return true;
  }

  // Helper methods available to all adapters

  /**
   * Get the ai-tools directory in the project
   */
  getAiToolsDir(projectRoot) {
    return path.join(projectRoot, 'ai-tools');
  }

  /**
   * Get current timestamp
   */
  getTimestamp() {
    return new Date().toISOString();
  }

  /**
   * Generate header comment for generated files
   */
  getGeneratedHeader() {
    return `# Generated by Korsakov v1.0.0
# Do not edit directly - regenerate with: npm run korsakov:generate
# Generated at: ${this.getTimestamp()}
`;
  }

  /**
   * Get agents from config
   */
  getAgents(config) {
    const agentIds = config?.agents?.selected || [];
    const agentsDir = path.join(this.templatesDir, 'agents');

    if (!fs.existsSync(agentsDir)) {
      return [];
    }

    const agents = [];

    for (const agentId of agentIds) {
      const agentFile = path.join(agentsDir, `${agentId}.md`);
      if (fs.existsSync(agentFile)) {
        const parsed = readMarkdownFile(agentFile);
        if (parsed) {
          agents.push({
            id: agentId,
            name: parsed.frontmatter.name || extractFirstHeading(parsed.body) || agentId,
            description: parsed.frontmatter.description || '',
            model: parsed.frontmatter.model || 'sonnet',
            filePath: agentFile
          });
        }
      }
    }

    return agents;
  }

  /**
   * Get all skills from templates
   */
  getSkills() {
    const skillsDir = path.join(this.templatesDir, 'skills');

    if (!fs.existsSync(skillsDir)) {
      return [];
    }

    const skills = [];
    const entries = fs.readdirSync(skillsDir, { withFileTypes: true });

    for (const entry of entries) {
      if (entry.isDirectory()) {
        const skillFile = path.join(skillsDir, entry.name, 'SKILL.md');
        if (fs.existsSync(skillFile)) {
          const parsed = readMarkdownFile(skillFile);
          if (parsed) {
            skills.push({
              id: entry.name,
              name: parsed.frontmatter.name || extractFirstHeading(parsed.body) || entry.name,
              description: parsed.frontmatter.description || '',
              dirPath: path.join(skillsDir, entry.name),
              filePath: skillFile
            });
          }
        }
      }
    }

    return skills;
  }

  /**
   * Get all commands from templates
   */
  getCommands() {
    const commandsDir = path.join(this.templatesDir, 'commands');

    if (!fs.existsSync(commandsDir)) {
      return [];
    }

    const commands = [];
    const files = getMarkdownFiles(commandsDir, ['README.md']);

    for (const filePath of files) {
      const parsed = readMarkdownFile(filePath);
      if (parsed) {
        const id = path.basename(filePath, '.md');
        commands.push({
          id,
          name: parsed.frontmatter.name || extractFirstHeading(parsed.body) || id,
          slashCommand: `/${id}`,
          description: parsed.frontmatter.description || '',
          audience: parsed.frontmatter.audience || 'human',
          filePath
        });
      }
    }

    return commands;
  }

  /**
   * Generate reference content for non-Claude adapters
   * This teaches the AI how to use Korsakov by reading ai-tools/
   */
  generateReferenceContent(config, title = 'Korsakov AI Framework') {
    const agents = this.getAgents(config);
    const skills = this.getSkills();
    const commands = this.getCommands();

    let content = `${this.getGeneratedHeader()}

# ${title}

Korsakov is your AI development team with specialized agents working in parallel.

## Your AI Team

| Agent | Role |
|-------|------|
`;

    for (const agent of agents) {
      content += `| @${agent.id} | ${agent.description || agent.name} |\n`;
    }

    content += `
## How to Use Korsakov

### 1. Reading Agent Definitions

When you need to act as a specific agent, read their definition:
\`\`\`
ai-tools/agents/{agent-name}.md
\`\`\`

### 2. Reading Skills

Skills are reusable patterns. Read them when needed:
\`\`\`
ai-tools/skills/{skill-name}/SKILL.md
\`\`\`

### 3. Reading Commands

Commands define workflows. Read them when invoked:
\`\`\`
ai-tools/commands/{command-name}.md
\`\`\`

## Available Commands

| Command | Purpose |
|---------|---------|
`;

    for (const cmd of commands) {
      content += `| ${cmd.slashCommand} | ${cmd.description || cmd.name} |\n`;
    }

    content += `
## Available Skills

| Skill | Purpose |
|-------|---------|
`;

    for (const skill of skills) {
      content += `| ${skill.id} | ${skill.description || skill.name} |\n`;
    }

    content += `
## Agent Delegation Protocol

**CRITICAL: You are the orchestrator, NOT the implementer.**

1. **NEVER implement directly** - Delegate to specialized agents
2. **Use @ mentions** - Reference agents like @backend-engineer
3. **Read before acting** - Always read the agent's definition first
4. **Parallel execution** - Dispatch independent work simultaneously

## Wave-Based Execution

Korsakov uses wave-based parallel execution:

\`\`\`
WAVE 1 (No Dependencies - All Parallel):
├── @tech-lead: Database schema
├── @frontend-engineer: UI mockups
└── @qa-release: Test plan

WAVE 2 (After Wave 1):
├── @backend-engineer: API endpoints
└── @frontend-engineer: UI components

WAVE 3 (After Wave 2):
└── @qa-release: Integration testing
\`\`\`

## Project Memory

All context persists in \`docs/ai/\`:
- \`project-overview.md\` - Vision and goals
- \`tech-stack.md\` - Technology inventory
- \`current-work.md\` - Active work tracking
- \`work/*/prd.md\` - PRD files for features

## Key Principles

1. **Agents are specialists** - Each has deep domain expertise
2. **Unlimited parallelism** - Dispatch all independent work simultaneously
3. **Memory persists** - Context tracked in docs/ai/
4. **Progress over perfection** - Ship incrementally
`;

    return content;
  }

  /**
   * Log generation result
   */
  logResult(result) {
    const { log, success, warn, error, colors } = require('../core/utils');

    if (result.success) {
      success(`${this.vendorName}: Generated ${result.files?.length || 0} files`);
      if (result.files) {
        for (const file of result.files) {
          log(`  → ${file}`, colors.dim);
        }
      }
    } else {
      error(`${this.vendorName}: ${result.error}`);
    }
  }
}

module.exports = { BaseAdapter };
